DOM
1. Document Object Model
Фактически это и есть HTML-разметка: блоки, из которых состоит документ
Интерфейс, позволяющий JS работать с разметкой документа

Элементы DOM-дерева можно посмотреть во вкладке elements инструментов разработчика

Узел - любое ветвление дерева, все сущности, которые мы можем увидеть на странице, в том числе и элементы. Возникает, где есть:
- открывающий тэг
- текст 
- HTML-комментарий

Элементы - тэги
Текстовые узлы - тексты
Узлы-комментарии - комментарии


2. Поиск элементов в DOM-дереве

Методы:
.querySelector('...') - будет применяться к первому попавшемуся элементу с заданным селектором
.querySelectorAll('...') будет применяться ко всем элементам с заданным селектором

Применяются к document, вышестоящим классам, тэгам и id в DOM-дереве, а также вышестоящим переменным:
(document - во всём документе)

document.querySelector('#container');
container.querySelector('.content');
* id начинать с #, класс начинать с .

Можно искать по вложенным селекторам:
document.querySelectorAll('section.bag div.bag .item');

.getElementById - получить элемент по идентификатору
.getElementByClassName - получить элемент по имени класса
.getElementByTagName - получить элемент по имени тэга

Данные 3 метода не поддерживают составные селекторы. Имена селекторов указываются без # и .
В целом они устаревшие и редко используются


3. Методы атрибутов
* эти методы срабатывают не на самом элементе, а на его представлении в DOM-объекте

.getAttribute('имя_атрибута')  - получаем значение атрибута
Если атрибута нет или атрибута не существует, вернётся значение null
Если у атрибута не бывает значений (disabled), то получим пустую строку

.hasAttribute('имя_атрибута') - есть ли у тэга заданный атрибут - получаем true or false

.setAttribute('имя_атрибута', 'значение')
Оба аргумента - строки, но если задать не строку, то они всё равно будут приведены к строке
Если значения нет (disabled), то написать в значении можно что угодно

!!! Можно прописывать CSS-св-ва:
resetButton.setAttribute('style', 'background-color:#f1f1f1');

.removeAttribute('имя_атрибута')

3.1 Замена атрибута через св-во DOM-элемента

resetButton.style.backgroundColor = '#f1f1f1';

Если задать тэгу атрибут, которого у него быть не должно, то соответствующее св-во не появится (но значение атрибута получить можно)


4. Манипуляции с классами CSS
*точку в аргументах у класса писать не нужно

.className - получить название класса (или классов)
.className = '...' - перезаписать название класса

.classList - получить список всех классов элемента (+ имеет свои методы)

.classList.contains('...') - проверяет, есть ли у элемента класс, переданный как аргумент (true or false)

.classList.add('...') - добавляет элементу класс

.classList.remove('...') - удаляет у элемента класс

.classList.toggle('...') - добавляет или удаляет у элемента класс, в зависимости от того, есть он или нет


5. Управление содержимым HTML
Нижеуказанные св-ва универсальные и есть у всех элементов DOM-дерева

.innerHTML - выведет наполнение элемента
напр, document.body.innerHTML - выведет содержимое body

.innerHTML = '...' - замента значения (если ранее было что-то другое, то оно перезапишется)

*Чтобы добавить несколько элементов, и они не перезаписывали бы друг друга, достаточно вместо знака = поставить знак конкатенации += либо после = написать старую функцию с + 'новое содержание'


.textContent - получить или перезаписать текстовое содержимое элемента
paragraph.textContent = 'А это новый текст.'

*если внутри текстового элемента есть дочерние элементы, их содержимое склеится
Поэтому не рекомендуется обращаться к св-ву textContent элементов, в которые вложены другие


.innerText - тоже показывет текстовое содержимое. Отличается от .textContent тем, что возвращает только видимое текстовое содержимое (проигнорирует элементы со св-вом display: none)
*Используется реже, тк менее стандартизировано и может не работать в некоторых браузерах


Также недостаток всех св-в в п.6 в том, что при их использовании всё DOM-дерево, вложенное в элемент, удаляется и пересоздаётся заново
В таком случае новые элементы дерева "забывают" все св-ва, которые были установлены через JS

Для гибкой вставки используются методы:

.insertAdjacentHTML('_место_', '_html_')
вместо места мб поставлены:
- beforebegin - до открывающего тэга
- beforeend - перед закрывающим тэгом
- afterbegin - после открывающего тэга
- afterend - после закрывающего тэга

.insertAdjacentText() - то же самое

В этих методах для добавления новых элементов не нужно делать конкатенацию += , новые элементы будут добавляться самы

*через innerHTML и insertAjacentHTML нельзя вставить <script>, тк это может создать уязвимость (Cross-site Scripting, XCC)
Но можно, например, позволить через эти методы вставить пользователю свой текст, а он может вставить скрипт

6. Другие св-ва
*только у некоторых элементов

.value  - значение поля ввода
полезно использовать, чтобы передавать введённое значение другому элементу:
<h4 class="song__artist">${song.value}</h4>
song.value = '';

.checked - true of false - у чекбоксов и радиокнопок (отмечены или нет)

Методы:
console.dir - отразит список св-в и методов переданного объекта
console.dir(document.body);
