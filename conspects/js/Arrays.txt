1. Массив - структура данных, в которой собраны несколько элементов (строго по порядку). Элементы перечисляются через запятую и заключены в квадратные скобки.
- Каждый элемент массива имеет свой порядковый номер — индекс. Счёт начинается с нуля.

Массивы создают для работы с однотипными данными

Массив определяется: let Имя массива = ["элемент1","элемент2","элемент3"];
Вызывается элемент массива: console.log(Имя массива[номер элемента]);
*Фразы в качестве элементов для удобства можно записывать в столбик
** (В качестве элементов массива мб не только строки и числа, но и картинки, объекты, другие массивы, а мб пустой массив)

2. Примеры:
const answers = []
answers[0] = 'one' - вставить элемент в массив

arr[number]; - обращение к элементу массива (arr) под номером (number)

3. Перебор всех свойств массива - конструкция (цикл) for of
for (let value of arr) {
	console.log(value);      (где value будет каждым отдельным
					элементом каждый тик)
}

2) через цикл for i
for (let value of arr) {                   
     console.log(value);
}

for of действует также со строкой, псевдомассивами и map и set (???)
циклы хороши тем, что там можно использовать break и continue, если нужно пропустить одно повтороение или остановить цикл
в .forEach() такое не сработает

3) через метод .forEach();
4) ещё несколько методов (которые кроме перебора ещё и изменяют массив)

4. Св-во .length - возвращает длину массива
Вывести последний элемент:
console.log(morningList[morningList.length - 1]);

Добавить новый элемент в конец:
morningList[morningList.length] = 'Помыть посуду';

5. Псевдомассивы - объект, структура которого совпадает со структурой массива, но не имеющий методов


Из ЯП:

6. Добавление элементов
метод:
.concat('...') - добавляет элемент и создаёт новый массив

*в аргументе мб и другой массив
const newArr = oldArr.concat(arr1, arr2);


7. Преобразование в строку
.join()
если аргумент пустой, то элементы будут перечисленны через запятую
в аргумент можно записать разделитель (пример: (' | ')

7.1 не забыть: .split(разделитель) - преобразование строки в массив

8. Добавление и удаление последнего элемента
.push('...') - добавить элемент в конец
.pop() - удалить последний элемент. без аргумента (в консоли выведется удалённый аргумент)

9. Добавление и удаление первого элемента
.shift() - удаляет первый элемент массива (в консоли выведется удалённый элемент)

.upshift('...') - добавляет элементы в начало массива (в консоли выведет сколько элементов в новом массиве)


*обычно добавляют и удаляют в конце, тк это менее затратно - изменяются только последние элементы, а, если добавить в начало, то изменятся индексы всех элементов

10. 
.slice(n1, n2) - вырезать часть массива. n1 - начало (включительно), n2 - конец (не включительно). создаётся новый массив

*если не указать второй аргумент - то вырезается массив до конца
** если указать отрицательные числа, то индекс будет считаться с конца (тут нету 0, счёт идёт сразу с -1)
*** если вызвать slice без аргументов, то получится новый такой же массив

.splice (n1, n2, '...') - вырезать часть элементов и заменить другими. 
n1 - начало, с которого вырезать
n2 - кол-во элементов на удаление
3-й аргумент - элементы, которые вставятся вместо удалённых (мб сколько угодно или 0)

в консоль выведутся удалённые элементы
старый массив изменится
* можно ничего не добавлять, тогда просто удалятся элементы
** можно ничего не удалять, тогда просто добавятся элементы, начиная с n1

*splice используют намного реже, чем slice


11. Коллекции в DOM
Коллекции - массивоподобные сущности, но не массивы
Объект считается массивоподобным, если:
- его элементы имеют числовые индексы
- есть св-во length

примеры:
NodeList (получается с помощью querySelectorAll) - есть метод forEach, св-во length
HTMLCollection (получается свойством .children) - нет методов

Чтобы превратить псевдомассив в массив, используется метод:
Array.form(arr1);


12. Перебор массива
Обход массива, метод:
.forEach(func) - в аргументе функция, которая вызывается на каждом элементе поочерёдно

how.forEach(function (item) {
    console.log(item + '.');
});

при каждом вызове forEach передаёт функции текущий элемент массива в качестве аргумента (item)

const elements = document.querySelectorAll('.text');

elements.forEach((item) => {
   item.classList.add('text_is-active');
}); 

* по сути forEach более удобный способ написания цикла for
** но в forEach нельзя использовать директивы continue и break

12.1
Создание одного массива из другого, метод:
.map(func) - в аргументе используется функция, которая преобразует элементы старого массива в новый

const secondArr = firstArr.map(function (item) {
  return item * item;
}); 


*если не написать return, функция сработает, но вернёт undefined
** нельзя применить к массивоподобным объектам. в таком сучае нужно превратить его в массив с использованием Array.form()


map лучше использовать, когда нужно сохранить исходный массив


13. Функции обратного вызова (колбэки) в методах массивов forEach и map

аргументы:
1) текущий элемент массива (как правило item)
2) индекс текущего элемента (index): выдаёт индекс в новом массиве (`${index + 1}`)
3) исходный массив (когда нужно обратиться к св-вам исходного массива (array.length)

const ivansIndexed = ivans.map(function(item, index, array) {
  const currentIndex = `(${(index + 1)} из ${array.length})`;
  return `${item} ${currentIndex}`;
});
console.log(ivansIndexed);

14. Отбор элементов массива
метод:
.filter(func) - отсеивает элементы массива по заданному признаку. Колбэк-функция вызывается на каждом элементе, проверяет его и возвращает true/false в зависимости от условий

const b = a.filter(function (item) {
  return item > 5
});

В итоге создаётся новый массив из элементов, для которых функция-фильтр вернула true

В коллбэке мб 3 параметра, как и в forEach, map

const b = a.filter(function (item, position, array) {
  return array.lastIndexOf(item) === position;
});

14.1 
метод: .includes('...') - проверяет содержимое на наличие указанного в скобках

Ещё пример:
const cardsFiltered = cards.filter(function (card) {
  return parseInt(card, 10) && (card.includes('червей') || card.includes('бубен'));
});


14.2 
методы: .endsWith, .startsWith - тоже помогают в проверке


15. Проверка элементов массива
методы:
1) .some - есть ли хотя бы один элемент, который соответствует условию в коллбэке
возвращается true/false

const nemo = oceanResidents.some(function (resident) {
    return resident === 'Немо';
});
console.log(nemo); // true 

const includesCrow = birds.some(function (bird) {
    return bird.includes('ворона');
});
console.log(includesCrow); // true

*коллбэк принимает также 3 аргумента
** проверка прекращается, если найден первый удовлетворяющий условиям элемент (оставшиеся не проверяются)

2) .find - возвращает значение элемента, на котором он завершил проверку
*прекращает перебор после того, как найдёт первое значение true

const crow = birds.find(function (bird) {
    return bird.includes('ворона');
});
console.log(crow); // "Чёрно-белая ворона"

3) .every - проверяет все элементы массива и возвращает true, если все элементы прошли проверку


16. Сведение массива
метод .reduce(func) - перебирает элементы массива и приводит их к итоговому значению (числу, массиву или объекту)

имеет 4 аргумента (3 старых и 1 - новый, который ставится в начале)
новый аргумент - промежуточное значение, равен тому, что в прошлой итерации вернул колбэк (previousValue)

const sum = arr.reduce(function (previousValue, item) {
  return previousValue + item;
});


Можно задать 2-й аргумент для .reduce (после колбэка) - это будет начальное значение

const total = winsAndLoses.reduce(function (previousValue, item) {
    return previousValue + item;
}, 1000);

либо можно записать так:
const total = 1000 + winsAndLoses.reduce(function (previousValue, item) {
  return previousValue + item;
});
(но последний способ не подойдёт, когда на выходе нужен массив или строка


Подсчёт элементов в объекте:
const order = ['яблоко', 'банан', 'апельсин', 'банан', 'яблоко', 'банан'];

const result = order.reduce(function (prevVal, item) {
  if (!prevVal[item]) {
    // если ключа ещё нет в объекте, значит это первое повторение
    prevVal[item] = 1;
  } else {
    // иначе увеличим количество повторений на 1
    prevVal[item] += 1;
  }

  // и вернём изменённый объект
  return prevVal;
}, {}); // Начальное значение — пустой объект.

console.log(result); // { яблоко: 2, банан: 3, апельсин: 1 } 


Частые ошибки:
1) забыть передать второй аргумент .reduce (начальное значение)
2) забыть return внутри колбэка


17. Сортировка массива
метод .sort()
аргумент - коллбэк либо без аргумента

1) если нет аргумента, то сортировка будет по возрастанию цифр (не в логическом порядке; числа сортируются как строки)

const myNumbers = [0, 3.14, 2.718, 13];
myNumbers.sort();
myNumbers; // [0, 13, 2.718, 3.14] 

const fruits = ['яблоко', 'банан', 'апельсин', 'томат'];
fruits.sort(); // ["апельсин", "банан", "томат", "яблоко"] 

2) в коллбэке описывается логика сортировки
в коллбэке 2 аргумента: 2 элемента массива, которые нужно сравнить

метод sort расставляет элементы исходя из значения, которое возвращает коллбэк (return a - b)

-если меньше нуля, то первый элемент встанет в массиве раньше второго
- если больше нуля, то второй элемент встанет раньше первого
- равно нулю - порядок не изменится

пример:
const myNumbers = [0, 3.14, 2.718, 13];

myNumbers.sort(function (a, b) {
    return a - b;
});
console.log(myNumbers); // [0, 2.718, 3.14, 13]


3) по возрастанию: a - b
по убыванию: b - a

4) * если элементы массива - строки - то результат будет NaN

для строк:
diagnoses.sort(function(a, b) {
  /* приведём строки к нижнему регистру,
  чтобы сравнение прошло коректно */
  a = a.toLowerCase();
  b = b.toLowerCase();

    if (a < b) return -1; // a расположится раньше b
    if (b < a) return 1; // b расположится раньше a

  return 0;
});

Пример, когда в строке несколько слов, а нужно отсортировать по одному:
chessChampions.sort(function (a, b) {
    a = a.split(' ')[1].toLowerCase();
    b = b.split(' ')[1].toLowerCase();

    if (a < b) return -1;
    if (b < a) return 1;
  
  return 0;
});

5) метод .localeCompare - более надёжный способ сравнения строк. он учитывает особенности разных языков

6) есть ещё сортировка пузырьком (посмотреть потом)