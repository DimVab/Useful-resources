1. Функция - код, который может использоваться много раз
Функции в JS - это значения, такие же как числа или строки
-Имя функции
-Тело функции
-Параметры функции - переменные, которыми может пользоваться только сама функция / иногда называется аргументом
-функция объявляется
-функция вызывается

Объявляется функция ключевым словом function (function sayHello () {...} )
Вызывается: sayHello();
Функции выгодны, когда содержат много строк кода, и их не нужно каждый раз копировать или переписывать

*Негласное правило: ф-я дб глаголом с припиской того, над чем выполняется действие
Ф-я мб анонимная, когда она выполняется сразу же, но впоследсвии её нельзя переиспользовать

Функция может быть с параметром ( функция(параметр); ). Параметр находится также в коде функции. При вызове функции в скобках указывается аргумент - конкретное значение, которое подставляется в коде вместо параметра). Параметров мб бесконечное кол-во
(*в принципе аргумент и параметр - одно и то же)
Пример:
function showText(text) {
	console.log(text);
}
showText("Hello!");

Также в параметр можно передать переменные:
let a = 10;
function(a);

2.
Способы создания функций:

1) объявление функции
 function-declaration - создаётся до начала выполнения скрипта. Её (как и var) код видит до выполнения кода, и её можно вызвать перед объявлением. (function name() {...} ) (*синтаксис: после фигурных скобок НЕ ставится ";")

2) function-expression (функциональное выражение - функция объявлена внутри другого выражения) - объявляется переменная, а внутри помещается функция. Такую функцию можно использовать только после объявления
( let name = function () {...}; ) (*синтаксис: после фигурных скобок ставится ";" ,тк создаётся переменная)
Вызывается с помощью name(); (обяз с круглыми скобками)

const multiply = function (a, b) {
  return a * b;
};
multiply(2, 3); // 6 

функция внутри аргумента - тоже функциональное выражение

функциональным выражением мб анонимная функция (коллбэк, метод или др)

arr.map(function (item) {
  return item * 2;
}); 

*объявленную функцию можно вызвать до объявления, функциональное выражение - нет

3) стрелочная функция (появилась в ES6): 
Стрелочными мб только функциональные выражения

const calc = (a, b) => { return a + b };
более короткая запись
не имеет контекста вызова (???? это что???)
* если функция только в одну строку, то фигурные скобки можно не ставить. если аргумент один, то скобки тоже не ставятся

const/let, имя, параметры (), оператор =>, тело

* если директива return - единственное д-е в теле стрелочной ф-ции, то можно опустить и директиву return и фигурные скобки

const shorterSingleAnecdote = (anecdote) => `я знаю только один анекдот: ${anecdote}`;

** если возвращаемое значение - объект, его нужно заключить в круглые скобки (иначе JS воспримет объект как тело функции)

const colorHex = () => ({ white: '#FFF' });

*** если у стрелочной функции один параметр, можно не знаключать его в скобки

const boatArrival = survivor => {
  console.log(`до другого берега доберётся только ${survivor}`);
};

**** стрелочная функция в коллбэке
array.forEach(() => {
  console.log('Кнопка нажата!');
}); 

const newArray = array.map(elem => elem * 2);

3.
Если функции идут одна за другой, это не значит, что выполняться они будут также. Разные функии могут иметь разную скорость выполнения. Могут иметь задержку выполнения.
Для решения такой проблемы используются callback-функции. Callback-функция - функция, которая дб выполнена, после того, как другая ф-я завершила своё выполнение
По сути это функция внутри функции (не первая по счёту). *Она записывается в аргумент без скобок!
[коллбэки часто спользуются в серверном программировании (node.js), в событиях js (которые должны повторяться один за другим)]


Работает так:
let element = document.querySelector('.my-element');

function showClick() {
  console.log('Мы кликнули по элементу');
}

element.addEventListener('click', showClick); 

либо

let element = document.querySelector('.my-element');

element.addEventListener('click', function () {
  console.log('Мы кликнули по элементу');
}); 


Такие функции (которые передаются в качестве аргумента в скобках другой функции) называются call-back-функции. Они вызываются после той функции (метода), в аргументе которого находятся


4. Возвращаемое значение - оператор return. Используется для сохранения значения для дальнейшего использования
return arr[randIndex]

Return (ключевое слово) - возвращение значения. Как только ф-я увидит return - она прекратит своё д-е. Код в функции после return будет недействительным. (по сути return позволяет использовать результат функции вне её)
Можно использовать return с переменной:
return _name_; - сохранение значения _name_
или само по себе: return; - прекращение работы. Если вызвать в таком случае значение в консоль, то она определит его как undefined
Можно комбинировать в return переменную и строку(либо другой тип данных):
return year + ' год - високосный';

* в return возвращаемая функция пишется без скобок 


5. Область видимости функции

-Переменная внутри функции снаружи недоступна. (называется локальная переменная)
-Функция может использовать и изменять глобальную переменную
-Если наименования локальной и глобальной переменной совпадают, то вне функции используется в приоритете глобальная переменная, а внутри функции - локальная
(затенение идентификаторов, внутренняя переменная затеняет внешнюю)
-вложенные области видимости: переменная мб внутри функции, которая внутри функции; тогда переменные ищутся снизу вверх (по всплытию)

с функциями также:
- если имена функций совпадают, то внутри функции в приоритете используется локальная функция


6. Аргумент по умолчанию

Если аргумент не передан функции или равен undefined, то параметр принимает значение, указанное по умолчанию (число, строка, объект, функция)

function generateName(firstName, lastName, middleName = '<без отчества>') {
    return `${firstName} ${middleName} ${lastName}`;
}

generateName('Маша', 'Петрова'); // Маша <без отчества> Петрова

Значением одного параметра функции мб другой её параметр:

const whacAMole = (startScore = 0, endScore = startScore) => {
    for (let i = 0; i <= 10; i += 1) {
        endScore = Math.random() > 0.5 ? endScore + 1 : endScore;
    }

    return endScore;
} 

*аргументы по умолчанию полезны при работе с сервером
** полезны для сокращения кода (удалить условные конструкции)


7.Функции с неопределённым числом аргументов

оператор <...> (три точки)

1) при вызове функции - называется spread - раскладывает массив в отдельные аргументы функции

const nums = [4, 8, 15, 16, 23, 42];
Math.max(...nums); // 42 

2) при объявлении функции - называется rest - собирает аргументы в массив

function consoleDogs(firstDog, ...otherDogs) {
  console.log(`Первый: ${firstDog}`);
  console.log(`Остальные: ${otherDogs}`);
}
consoleDogs('Спаниель', 'Овчарка', 'Борзая', 'Метис');

Первый: Спаниель
Остальные: ['Овчарка', 'Борзая', 'Метис']

*rest-параметр всегда стоит в конце

3) псевдомассив arguments (любой функции, кроме стрелочной) всех аргументов, которые были переданы функции. создаётся автоматически

function gimmeSomeArguments() {
  console.log(arguments);
}
gimmeSomeArguments(1, 2); // [1, 2]

* у arguments отсутствуют методы forEach и map