1.1 Параметры установки окончаний строк (зачем?):

git config --global core.autocrlf true
git config --global core.safecrlf warn

1.2 Установка отображения unicode
git config --global core.quotepath off


2.1 Отменить изменения

git restore _name_.abc
git checkout _name_.abc
* работают до того как добавлены в отслеживаемые. (+ вроде как не работают с -А)

2.2 Убрать файл из отслеживаемых

git restore --staged _name_.abc
git reset _name_.abc
git reset HEAD _name_.abc


3. Добавив файлы в список отслеживаемых, можно продолжать вносить в них изменения. Но если их не проиндексировать заново, то коммит будет на момент добавления в список отслеживаемых

Коммиты можно разделять разными названиями, добавляя перед ними в отслеживаемые определённые файлы

3.1 Если не добавить в git commit метку  -m, то git откроет редактор
Ребактор выбирается по следующему приоритету:
1) переменная среды GIT-EDITOR
2) параметр конфигурации core.editor
3) переменная среды VISUAL
4) переменная среды EDITOR
(по умолчанию Vim)

Чтобы сохранить изменения, нужно сохранить файл и выйти. (В Vim нажать клавишу ESC, ввести :wq и нажать Enter)


4. Ключи для логов:
--online
--pretty="..."
%h
%d
%ad
%s
%an
--pretty=oneline
--max-count=2 (или другое число)
--since='5 minutes ago'
--until='5 minutes ago'
--author=<name>
--all
--graph
--date=short

Пример:
$ git log --pretty=format:"%h %ad | %s%d [%an]" --graph --date=short
Будет: * fa3c141 2011-03-09 | Added HTML header (HEAD, master) [author_name]

4.1 gitk - инструмент для просмотра истории изменений (!!!)


5. Алиасы (сокращения ключевых слов, шорткаты)
Для настройки выполнить:

git config --global alias.co checkout
git config --global alias.ci commit
git config --global alias.st status
git config --global alias.br branch
git config --global alias.hist "log --pretty=format:'%h %ad | %s%d [%an]' --graph --date=short"
git config --global alias.type 'cat-file -t'
git config --global alias.dump 'cat-file -p'

Ещё более сокращённые версии:
alias gs='git status '
alias ga='git add '
alias gb='git branch '
alias gc='git commit'
alias gd='git diff'
alias gco='git checkout '
alias gk='gitk --all&'
alias gx='gitx --all'

alias got='git '
alias get='git '


6. git checkout _hash-log_ - переместиться в коммит по номеру хэша и создать ему отдельную ветку

git tag _name_ - создать тэг для версии страницы (вместо хэша)
git tag -d _name_ - удалить тэг
git checkout v1^ - переключиться на предыдущую версию (^ - знак предыдищей версии)
git checkout v1^~1 - тоже самое
git tag - просмотр всех тэгов

Также тэги показываются в истории логов

7. git revert HEAD --no-edit - удалить последний коммит
(ключ --no-edit позволяет удалить без редактора)

git reset #hash/tag/branch - удалить все коммиты до указываемого
Удалённые коммиты мб видны при git log -all (т.е. они отсутствуют в ветке main)


8. Структура .git
HEAD - содержит ссылку на текущую ветку
config - настройки
refs/heads - ветки
refs/tags - тэги\
objects - объекты


git cat-file -t _hash_ - выводит тип хэша
git cat-file -p _hash_ - выводит объект коммита (tree, parent, author, committer), либо об
* везде используется сжатый 7-значный SHA1 хэш

Затем по хэшу tree можно вывести дерево каталогов верхнего уровня
По хэшу каталога можно вывести его содержимое
По хэшу файла можно вывести его содержимое

tree - каталог
blob - файл


9. Просмотр истории всех веток
с помощью ключа --all
(* по умолчанию показывается текущая ветка)

Серый цвет - общие коммиты
Зелёный - только текущая ветка
Красный - только другие ветки

Также различающиеся ветки начинаются с:
|
|/

Такэже текущая ветка помечается как HEAD

9.1 Разрешение конфликта при слиянии (урок 30) не очень понял. Сделать на др учебном проекте ещё раз и посм видео

Пишут что нужно вручную изменить, а потом сделать коммит

9.2 Преобразование вместо слияния

git rebase - перебазирование изменений из одной ветки в другую

При перебазировании дерево коммитов ветки, в которую вливают переписывается таким образом, что коммиты вливаемой ветки являются её частью

Не использовать перебазирование:

1) Если ветка является публичной и расшаренной. Переписывание общих веток будет мешать работе других членов команды.
2) Когда важна точная история коммитов ветки (так как команда rebase переписывает историю коммитов)

использовать rebase лучше для кратковременных, локальных веток, а слияние для веток в публичном репозитории.


10. Работа с несколькими репозиториями

git clone _name_ _cloned_name_

git remote
origin (имя удалённого репозитория по умолчанию)

git remote show origin - показать инф об оригинальном репозитории

Существует традиция называть первичный централизованный репозиторий origin

В инф показываются:
fetch url
push url
HEAD branch
remote branches

*при клонировании остаётся только одна ветка main

10.1 
git branch выводит спистк локальных веток по умолчанию (main)

git branch -a  - просмотр всех веток в локальном репозитории
Git выводит все коммиты в оригинальный репозиторий, но ветки в удалённом репозитории не рассматриваются как локальные
Все оригинальные ветки в локальном начинаются с remotes/origin

10.2 git fetch - загрузить проект с изменениями с удалённого репозитория без слияния с рабочей веткой (видимо появятся другие ветки)
Затем можно слить ветку с изменениями командой merge

git pull сразу сливает рабочую ветку с изменениями

git pull = git fetch; git merge "..."


11. git clone --bare _project1_ _project1_.git - создание чистого репозитория

Чистый репозиторий - репозиторий только со служебной информацией в .git без рабочих файлов
(дельты изменений, бинарные данные)

11.1 
git remote add shared ../_project1_.git - добавить чистый репозиторий в качестве удалённого репозитория
(зачем?)